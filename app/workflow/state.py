"""State definition for LangGraph workflow."""

from typing import List, Optional, Dict, Any
from pydantic import BaseModel, Field
from datetime import datetime
from enum import Enum


class IssueSeverity(str, Enum):
    """Severity levels for review issues."""
    BLOCKER = "blocker"
    MAJOR = "major"
    MINOR = "minor"
    NIT = "nit"


class IssueCategory(str, Enum):
    """Category types for review issues."""
    CORRECTNESS = "correctness"
    SECURITY = "security"
    PERFORMANCE = "perf"
    STYLE = "style"
    TEST = "test"
    DOCS = "docs"


class EffortEstimate(str, Enum):
    """Effort estimation for fix tasks."""
    SMALL = "S"
    MEDIUM = "M"
    LARGE = "L"


class HITLAction(str, Enum):
    """Human-in-the-loop decision actions."""
    APPROVE = "approve"
    EDIT = "edit"
    REJECT = "reject"
    POST_SUMMARY_ONLY = "post_summary_only"


class ReviewIssue(BaseModel):
    """A single review issue found by the Reviewer Agent."""
    severity: IssueSeverity
    category: IssueCategory
    file_path: str
    line_number: int
    explanation: str
    suggestion: str
    evidence_references: List[str] = Field(default_factory=list)
    
    class Config:
        use_enum_values = True


class FixTask(BaseModel):
    """A fix task generated by the Patch Planner Agent."""
    task_id: str
    title: str
    why_it_matters: str
    affected_files: List[str]
    suggested_approach: str
    effort_estimate: EffortEstimate
    related_issues: List[int] = Field(default_factory=list)  # Indices into issues list
    
    class Config:
        use_enum_values = True


class GuardrailResult(BaseModel):
    """Result from guardrail checks."""
    passed: bool
    blocked_reasons: List[str] = Field(default_factory=list)
    warnings: List[str] = Field(default_factory=list)
    checks_performed: List[str] = Field(default_factory=list)


class HITLDecision(BaseModel):
    """Human-in-the-loop decision."""
    action: HITLAction
    edited_content: Optional[str] = None
    feedback: Optional[str] = None
    timestamp: datetime = Field(default_factory=datetime.now)
    
    class Config:
        use_enum_values = True


class RetrievalBundle(BaseModel):
    """Context retrieved for a hunk."""
    hunk_id: str
    local_context: List[Dict[str, Any]] = Field(default_factory=list)
    similar_code: List[Dict[str, Any]] = Field(default_factory=list)
    conventions: List[Dict[str, Any]] = Field(default_factory=list)
    total_chunks: int = 0


class WorkflowState(BaseModel):
    """State for LangGraph workflow."""
    
    # Run metadata
    run_id: str
    started_at: datetime = Field(default_factory=datetime.now)
    
    # Repository and PR info
    repo_owner: str
    repo_name: str
    repo_id: str  # For Qdrant collection reference
    pr_number: int
    pr_sha: str
    diff_hash: str
    
    # Parsed hunks (from Phase 2)
    hunks: List[Dict[str, Any]] = Field(default_factory=list)
    
    # Retrieved contexts (Node 1 output)
    retrieval_bundles: Dict[str, RetrievalBundle] = Field(default_factory=dict)
    
    # Draft review comments (Node 2 output)
    review_issues: List[ReviewIssue] = Field(default_factory=list)
    
    # Fix plan (Node 3 output)
    fix_tasks: List[FixTask] = Field(default_factory=list)
    
    # Guardrail results (Node 4 output)
    guardrail_result: Optional[GuardrailResult] = None
    
    # HITL decision (Node 5 output)
    hitl_decision: Optional[HITLDecision] = None
    
    # Publisher output (Node 6)
    posted_comment_url: Optional[str] = None
    notification_sent: bool = False
    
    # Persistence tracking (Node 7)
    persisted: bool = False
    persistence_path: Optional[str] = None
    
    # Error tracking
    errors: List[str] = Field(default_factory=list)
    
    # Current node for routing
    current_node: Optional[str] = None
    
    class Config:
        arbitrary_types_allowed = True
