"""Node 6: Publisher + Notifier - Publish review and send notifications."""

from typing import Dict, Any, Optional
from datetime import datetime

from .state import WorkflowState, HITLAction


class PublisherNotifier:
    """Publisher and notification agent."""
    
    def __init__(self, github_token: Optional[str] = None):
        """
        Initialize publisher/notifier.
        
        Args:
            github_token: GitHub API token for posting comments
        """
        self.github_token = github_token
    
    def format_github_comment(self, state: WorkflowState) -> str:
        """
        Format review for GitHub PR comment.
        
        Args:
            state: Workflow state
            
        Returns:
            Markdown-formatted comment
        """
        lines = []
        
        # Header
        lines.append("## ðŸ¤– Automated Code Review")
        lines.append("")
        lines.append(f"*Generated by Repo-Copilot on {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}*")
        lines.append("")
        
        # Check if summary only
        if state.hitl_decision and state.hitl_decision.action == HITLAction.POST_SUMMARY_ONLY:
            lines.append(self._format_summary_only(state))
            return "\n".join(lines)
        
        # Check if edited content
        if state.hitl_decision and state.hitl_decision.edited_content:
            lines.append(state.hitl_decision.edited_content)
            return "\n".join(lines)
        
        # Full review
        # Summary stats - handle both enum and string
        def get_severity_str(issue):
            return issue.severity.value if hasattr(issue.severity, 'value') else str(issue.severity)
        
        blocker_count = sum(1 for i in state.review_issues if get_severity_str(i) == "blocker")
        major_count = sum(1 for i in state.review_issues if get_severity_str(i) == "major")
        minor_count = sum(1 for i in state.review_issues if get_severity_str(i) == "minor")
        nit_count = sum(1 for i in state.review_issues if get_severity_str(i) == "nit")
        
        lines.append("### ðŸ“Š Summary")
        lines.append("")
        lines.append(f"- ðŸ”´ Blockers: {blocker_count}")
        lines.append(f"- ðŸŸ  Major: {major_count}")
        lines.append(f"- ðŸŸ¡ Minor: {minor_count}")
        lines.append(f"- ðŸ”µ Nit: {nit_count}")
        lines.append(f"- **Total Issues**: {len(state.review_issues)}")
        lines.append("")
        
        # Issues by severity
        if state.review_issues:
            def get_severity_str(issue):
                return issue.severity.value if hasattr(issue.severity, 'value') else str(issue.severity)
            
            for severity in ["blocker", "major", "minor", "nit"]:
                severity_issues = [i for i in state.review_issues if get_severity_str(i) == severity]
                if severity_issues:
                    icon = {"blocker": "ðŸ”´", "major": "ðŸŸ ", "minor": "ðŸŸ¡", "nit": "ðŸ”µ"}[severity]
                    lines.append(f"### {icon} {severity.upper()} Issues")
                    lines.append("")
                    
                    for issue in severity_issues:
                        # Handle both enum and string for category
                        category_str = issue.category.value if hasattr(issue.category, 'value') else str(issue.category)
                        lines.append(f"**[{category_str.upper()}] `{issue.file_path}:{issue.line_number}`**")
                        lines.append("")
                        lines.append(f"{issue.explanation}")
                        lines.append("")
                        lines.append(f"ðŸ’¡ **Suggestion**: {issue.suggestion}")
                        lines.append("")
                        if issue.evidence_references:
                            lines.append(f"ðŸ“Ž **Evidence**: {', '.join(issue.evidence_references)}")
                            lines.append("")
                        lines.append("---")
                        lines.append("")
        else:
            lines.append("### âœ… No Issues Found")
            lines.append("")
            lines.append("Great work! The code looks good.")
            lines.append("")
        
        # Fix plan
        if state.fix_tasks:
            lines.append("### ðŸ”§ Suggested Fix Plan")
            lines.append("")
            for i, task in enumerate(state.fix_tasks, 1):
                lines.append(f"#### {i}. {task.title} `[{task.effort_estimate}]`")
                lines.append("")
                lines.append(f"**Why it matters**: {task.why_it_matters}")
                lines.append("")
                lines.append(f"**Affected files**: {', '.join(f'`{f}`' for f in task.affected_files)}")
                lines.append("")
                lines.append(f"**Approach**: {task.suggested_approach}")
                lines.append("")
        
        return "\n".join(lines)
    
    def _format_summary_only(self, state: WorkflowState) -> str:
        """Format a brief summary for summary-only mode."""
        lines = []
        
        lines.append("### Summary")
        lines.append("")
        
        total = len(state.review_issues)
        if total == 0:
            lines.append("âœ… No issues found. Code looks good!")
        else:
            by_severity = {}
            for issue in state.review_issues:
                # Handle both enum and string
                sev = issue.severity.value if hasattr(issue.severity, 'value') else str(issue.severity)
                by_severity[sev] = by_severity.get(sev, 0) + 1
            
            lines.append(f"Found {total} issue(s):")
            for sev in ["blocker", "major", "minor", "nit"]:
                if sev in by_severity:
                    lines.append(f"- {sev}: {by_severity[sev]}")
        
        return "\n".join(lines)
    
    def publish_to_github(self, state: WorkflowState) -> str:
        """
        Publish review to GitHub PR.
        
        Args:
            state: Workflow state
            
        Returns:
            URL of posted comment
        """
        # Format comment
        comment_body = self.format_github_comment(state)
        
        # TODO: Actually post to GitHub
        # For now, just print and return mock URL
        print("\n" + "=" * 80)
        print("GITHUB COMMENT (would be posted):")
        print("=" * 80)
        print(comment_body)
        print("=" * 80)
        
        # Mock URL
        mock_url = f"https://github.com/{state.repo_owner}/{state.repo_name}/pull/{state.pr_number}#comment-mock"
        
        return mock_url
    
    def send_slack_notification(self, state: WorkflowState) -> bool:
        """
        Send Slack notification.
        
        Args:
            state: Workflow state
            
        Returns:
            Success status
        """
        # TODO: Implement Slack integration
        print("\nðŸ“¢ Slack notification (not implemented):")
        print(f"   PR #{state.pr_number} reviewed - {len(state.review_issues)} issues found")
        
        return True
    
    def send_email_notification(self, state: WorkflowState) -> bool:
        """
        Send email notification.
        
        Args:
            state: Workflow state
            
        Returns:
            Success status
        """
        # TODO: Implement email integration
        print("\nðŸ“§ Email notification (not implemented):")
        print(f"   PR #{state.pr_number} reviewed - sent to reviewers")
        
        return True
    
    def __call__(self, state: WorkflowState) -> Dict[str, Any]:
        """
        LangGraph node function: publish review and send notifications.
        
        Args:
            state: Current workflow state
            
        Returns:
            Updates to state (posted_comment_url, notification_sent)
        """
        print(f"\nðŸ“¤ Publisher + Notifier: Publishing review...")
        
        try:
            # Publish to GitHub
            comment_url = self.publish_to_github(state)
            print(f"  âœ“ Review published: {comment_url}")
            
            # Send notifications
            slack_sent = self.send_slack_notification(state)
            email_sent = self.send_email_notification(state)
            
            notification_sent = slack_sent or email_sent
            
            return {
                "posted_comment_url": comment_url,
                "notification_sent": notification_sent,
                "current_node": "publisher"
            }
            
        except Exception as e:
            error_msg = f"Publishing failed: {e}"
            print(f"  âœ— {error_msg}")
            
            return {
                "posted_comment_url": None,
                "notification_sent": False,
                "current_node": "publisher",
                "errors": state.errors + [error_msg]
            }
